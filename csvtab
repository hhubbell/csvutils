#!/usr/bin/env python
#
# Author:       Harrison Hubbell <harrison.hubbell@logicsupply.com>
# Created:      11/09/2015
# Description:  Sum the specified columns from an input csv and
#               return the result to STDOUT. Use python3 for better
#               unicode support
#

from __future__ import print_function
import argparse
import csv
import sys

def align(values):
    """
    Determine alignment based on column datatype.
    :param values:      Column values
    :return string:     str.format microlanguage alignment character
    """
    try:
        [float(x) for x in values]
        alg = '>'
    except ValueError:
        alg = '<'

    return alg

def fmt(string, width, alignment='<'):
    """
    Return a formatted string for the cell
    :param string:      String to format
    :param width:       Cell width
    :param alignment:   Cell alignment str.format microlanguage alignment char
    :return string:     Formatted string
    """
    COLFMT = '{:{}{}}'
    return COLFMT.format(string, alignment, width)

def tabulate(header, rows, maxw=None, pad=0):
    """
    Format the table
    :param header:      Table header
    :param rows:        Table rows
    :option maxw:       Max cell width
    :option pad:        Cell padding
    :return list:       Formatted table in matrix like form.
    """
    full = list(rows)
    full.insert(0, header)
    flat = zip(*full)
    fmtcol = []

    for head, vals in zip(header, flat):
        calign = align(vals[1:])
        cmax = max(len(x) for x in vals) + pad
        cmax = maxw if maxw is not None and maxw < cmax else cmax
        fmtcol.append(map(
            lambda x: fmt(trunc(x, cmax), cmax, calign) if len(x) > cmax else fmt(x, cmax, calign),
            vals))

    return list(zip(*fmtcol))

def read(src, header=True, delimiter=','):
    """
    Open a specified CSV file and read it.
    :param src:         File path
    :option header:     CSV file has a header row
    :option delimiter:  CSV item delimiter
    :return tuple:      header, rows tuple
    """
    reader = csv.reader(src, delimiter=delimiter)
    head = next(reader) if header is True else None

    return head, list(reader)

def trunc(string, width, replace='...'):
    """
    Truncate a string if it exceeds the specified width, replacing
    the truncated data with an ellipsis or other.
    :param string:      String to truncate
    :param width:       Max string length
    :option replace:    Replace truncated data with
    :return string:     New truncated string
    """
    return string[:width - len(replace)] + replace

def write(header, rows):
    """
    Dump data to stdout
    :param header:      Table header
    :param rows:        Table rows
    """
    try:
        print(*header)
        for row in rows:
            print(*row)
    except IOError:
        pass

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('infile',
        type=argparse.FileType('r'),
        default=sys.stdin)
    parser.add_argument('-d', '--delim')
    parser.add_argument('-m', '--maxlength',
        type=int)
    parser.add_argument('-p', '--padding',
        type=int)

    args = parser.parse_args()

    infile = args.infile
    maxlength = args.maxlength
    padding = args.padding or 0
    delim = args.delim.decode('string-escape') if args.delim else ','

    header, rows = read(infile)
    fmtrows = tabulate(header, rows, maxlength, padding)
    fmtheader = fmtrows.pop(0)

    write(fmtheader, fmtrows)
